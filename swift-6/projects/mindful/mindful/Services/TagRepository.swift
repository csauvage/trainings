import Foundation
import SwiftData

/// Thread-safe repository for managing tags
actor TagRepository {
    private let modelContext: ModelContext

    init(modelContext: ModelContext) {
        self.modelContext = modelContext
    }

    func create(
        name: String,
        color: String = "#007AFF",
        isAutoGenerated: Bool = false
    ) async throws -> Tag {
        if let existingTag = try await fetch(byName: name) {
            return existingTag
        }

        let tag = Tag(
            name: name,
            color: color,
            isAutoGenerated: isAutoGenerated
        )

        modelContext.insert(tag)
        try modelContext.save()

        return tag
    }

    func fetch(id: UUID) async throws -> Tag? {
        let descriptor = FetchDescriptor<Tag>(
            predicate: #Predicate { tag in
                tag.id == id
            }
        )
        return try modelContext.fetch(descriptor).first
    }

    func fetch(byName name: String) async throws -> Tag? {
        let descriptor = FetchDescriptor<Tag>(
            predicate: #Predicate { tag in
                tag.name == name
            }
        )
        return try modelContext.fetch(descriptor).first
    }

    func fetchAll(sortBy: TagSortOrder = .name) async throws -> [Tag] {
        var descriptor = FetchDescriptor<Tag>()

        switch sortBy {
        case .name:
            descriptor.sortBy = [SortDescriptor(\.name, order: .forward)]
        case .createdDate:
            descriptor.sortBy = [SortDescriptor(\.createdAt, order: .reverse)]
        case .usageCount:
            descriptor.sortBy = [SortDescriptor(\.name, order: .forward)]
        }

        return try modelContext.fetch(descriptor)
    }

    func fetchManualTags() async throws -> [Tag] {
        let descriptor = FetchDescriptor<Tag>(
            predicate: #Predicate { tag in
                tag.isAutoGenerated == false
            },
            sortBy: [SortDescriptor(\.name, order: .forward)]
        )

        return try modelContext.fetch(descriptor)
    }

    func fetchAutoGeneratedTags() async throws -> [Tag] {
        let descriptor = FetchDescriptor<Tag>(
            predicate: #Predicate { tag in
                tag.isAutoGenerated == true
            },
            sortBy: [SortDescriptor(\.createdAt, order: .reverse)]
        )

        return try modelContext.fetch(descriptor)
    }

    func search(query: String) async throws -> [Tag] {
        let lowercasedQuery = query.lowercased()
        let descriptor = FetchDescriptor<Tag>(
            predicate: #Predicate { tag in
                tag.name.localizedStandardContains(lowercasedQuery)
            },
            sortBy: [SortDescriptor(\.name, order: .forward)]
        )

        return try modelContext.fetch(descriptor)
    }

    func update(_ tag: Tag, name: String? = nil, color: String? = nil) async throws {
        if let name = name {
            tag.name = name
        }
        if let color = color {
            tag.color = color
        }
        try modelContext.save()
    }

    func delete(_ tag: Tag) async throws {
        modelContext.delete(tag)
        try modelContext.save()
    }

    func deleteUnusedTags() async throws {
        let allTags = try await fetchAll()
        let unusedTags = allTags.filter { $0.entries.isEmpty }

        for tag in unusedTags {
            modelContext.delete(tag)
        }

        try modelContext.save()
    }

    func getUsageCount(for tag: Tag) async -> Int {
        tag.entries.count
    }

    func getMostUsedTags(limit: Int = 10) async throws -> [Tag] {
        let allTags = try await fetchAll()
        return allTags
            .sorted { $0.entries.count > $1.entries.count }
            .prefix(limit)
            .map { $0 }
    }

    func count() async throws -> Int {
        let descriptor = FetchDescriptor<Tag>()
        return try modelContext.fetchCount(descriptor)
    }

    func createBulk(names: [String], color: String = "#007AFF", isAutoGenerated: Bool = true) async throws -> [Tag] {
        var tags: [Tag] = []

        for name in names {
            if let existingTag = try await fetch(byName: name) {
                tags.append(existingTag)
            } else {
                let tag = Tag(name: name, color: color, isAutoGenerated: isAutoGenerated)
                modelContext.insert(tag)
                tags.append(tag)
            }
        }

        try modelContext.save()
        return tags
    }
}

enum TagSortOrder: Sendable {
    case name
    case createdDate
    case usageCount
}
